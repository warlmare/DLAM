
import os, random, helper, plotille, numpy as np, random, file_manipulation, csv
import termplotlib as tpl
import matplotlib.pyplot as plt
from time import sleep
from progress.bar import Bar
import pandas as pd

import csv


DATASET_FILETYPE = "pdf"
TRAINING_DATASET_SIZE = 50000
TEST_DATASET_SIZE = 5000
TEST_DATA_FILES_PATH = "../napierone"
SAMPLE_FILES_PATH = "../govdocs/all_files"
HASHING_ALGORITHM = "TLSH"
FRAGMENT_PERCENTAGE = 50


def get_sample_files(tr_dataset_size, filedirectory):
    '''selects TRAINING_DATASET_SIZE amount of files of DATASET_FILETYPE

    :param FILETYPE:
    :return: dict with paths to files
    '''
    filepaths_ext = []

    for file in os.listdir(filedirectory):
        if file.endswith(DATASET_FILETYPE):
            filepath = os.path.join(filedirectory, file)
            filepaths_ext.append(filepath)


    filesizes = []
    sample = random.sample(filepaths_ext, tr_dataset_size)
    for file in sample:
        filesizes.append(helper.getfilesize(file) / 1000000) # size in MB



    #converting array to numpy array
    filesizes = np.asarray(filesizes    )   #ataset_size = np.sum(filesizes)
    MAX_FILESIZE = np.max(filesizes) * 1000000
    #print("-" * 50, "FILESIZE DISTRIBUTION IN SAMPLE", "-" * 50)
    #print(plotille.histogram(filesizes, x_min=0, x_max=MAX_FILESIZE, y_min=0, y_max=TRAINING_DATASET_SIZE/2, X_label="Size in MB"))
    #print("DATASET SIZE: ", TRAINING_DATASET_SIZE, " MB")
    #print("-" * 131)


    filepaths_all = random.sample(filepaths_ext, tr_dataset_size)
    training_files = random.sample(filepaths_all, tr_dataset_size)
    # stores the difference of the list for training files and all files
    #rest_list = []

    #calculate the difference between the files already picked for trainging and all files 
    # in order to pick only so far un-picked files for testing
    #rest_list = list(set(filepaths_all) - set(training_files))
    #test_files = random.sample(rest_list, test_dataset_size)
    return training_files , int(MAX_FILESIZE)


def get_rand_bytes(byte_length: int):
    '''generates a random byte sequence of length byte_length

    :param byte_length:
    :return: byte sequence as byt object
    '''

    random_bytes = random.randbytes(byte_length)
    return random_bytes


def overwrite_with_chunk(filepath, fragment, fragment_size_percent):
    '''takes a random generated byte and a filepath.
    It insers fragment_size_percent (%) into a file (filepath)
    and copies the finished into a specified directory path.

    :param filepath:
    :param fragment:
    :return:
    '''


    filesize = helper.getfilesize(filepath)

    #calculates how long the fragment should be
    fragment_len = int(filesize * (fragment_size_percent * 0.01))

    #choose random position in byte object and cut fragment
    full_fragment_len = len(fragment)
    max_offset = full_fragment_len - fragment_len
    #print(max_offset)
    fragment_start_pos = 0 #random.randrange(0, max_offset)
    fragment_stop_pos = fragment_start_pos + fragment_len

    #choose random offset in file
    offset = file_manipulation.getrandoffset(filepath, fragment_len)

    #cut fragment_len from random pos in file
    fragment_ins = fragment[fragment_start_pos:fragment_stop_pos]

    # end is where the chunk ends and the second half begins
    end = offset + fragment_len
    f = open(filepath, "rb")
    first_half = f.read(offset)
    f.seek(end)
    second_half = f.read()
    f.close()

    # merging the three parts
    byt = first_half + fragment_ins + second_half

    # writing bytes to file (filepath)
    filename = helper.get_file_name(filepath)
    f = open("./dataset/anomalies/{}".format(filename), "wb")
    f.write(byt)
    f.close()

    fragment_filepath = "./dataset/anomalies/{}".format(filename)

    return fragment_filepath


def split_list(a_list):
    half = len(a_list)//2
    return a_list[:half], a_list[half:]

def generate_dataset(training_dataset_size, path):

    #generating a sample_set of files
    sample_files_paths, max_filesize = get_sample_files(training_dataset_size, path)

    #dividing the dataset into two parts
    list_a, normal_files = split_list(sample_files_paths)

    #generating a random sequence of bytes
    anomaly = get_rand_bytes(max_filesize)

    # creating a file with only the randomly generated files
    f = open("./dataset/anomaly", "wb")
    f.write(anomaly)
    f.close()

    anomaly_files = []

    ctr = 1
    for path in list_a:
        #insert fragments into file
        fragment_filepath = overwrite_with_chunk(path, anomaly, FRAGMENT_PERCENTAGE)
        anomaly_files.append(fragment_filepath)
        #print("DATASET GENERATION: {}/{}".format(ctr,TRAINING_DATASET_SIZE))
        ctr += 1



    return anomaly_files, normal_files

def generate_hashes_from_dataset(dataset_paths):

    hashes = []

    algorithm_instance = helper.get_algorithm(HASHING_ALGORITHM)

    for path in dataset_paths:
        sample_hash = algorithm_instance.get_hash(path)
        hashes.append(sample_hash)

    return hashes

def list_to_csv(list_x, filename):
    with open(filename, 'w', newline='') as myfile:
        wr = csv.writer(myfile)
        wr.writerow(list_x)




if __name__ == '__main__':

    training_anomaly_files, training_normal_files = generate_dataset(TRAINING_DATASET_SIZE, SAMPLE_FILES_PATH)
    training_anomaly_hashes = generate_hashes_from_dataset(training_anomaly_files)
    training_normal_hashes = generate_hashes_from_dataset(training_normal_files)
    list_to_csv(training_anomaly_hashes, "dataset/anomaly_hashes_training_{}_pdf_tlsh.csv".format("25000"))
    list_to_csv(training_normal_hashes, "dataset/normal_hashes_training_{}_pdf_tlsh.csv".format("25000"))

    
    test_anomaly_files, test_normal_files = generate_dataset(TEST_DATASET_SIZE, TEST_DATA_FILES_PATH)
    test_anomaly_hashes = generate_hashes_from_dataset(test_anomaly_files)
    test_normal_hashes = generate_hashes_from_dataset(test_normal_files)
    list_to_csv(training_anomaly_hashes, "dataset/anomaly_hashes_test_{}_pdf_tlsh.csv".format("2500"))
    list_to_csv(training_normal_hashes, "dataset/normal_hashes_test_{}_pdf_tlsh.csv".format("2500"))









